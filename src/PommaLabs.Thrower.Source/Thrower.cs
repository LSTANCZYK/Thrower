/*
 * File generated by SourceCombiner.exe using 38 source files.
 * Created On: 11/06/2017 08:30:43
 */
using Microsoft.CSharp.RuntimeBinder;
using PommaLabs.Thrower.ExceptionHandlers;
using PommaLabs.Thrower.ExceptionHandlers.IO;
using PommaLabs.Thrower.ExceptionHandlers.Net;
using PommaLabs.Thrower.Reflection;
using PommaLabs.Thrower.Validation;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Data;
using System.Data.Common;
using System.Diagnostics.CodeAnalysis;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
//*** SourceCombiner -> original file HttpException.cs ***
namespace PommaLabs.Thrower
{
    [Serializable]
    public struct HttpExceptionInfo
    {
        public HttpExceptionInfo(object errorCode = null, string userMessage = null)
        {
            ErrorCode = errorCode ?? HttpException.DefaultErrorCode;
            UserMessage = userMessage ?? HttpException.DefaultUserMessage;
        }
        public object ErrorCode { get; set; }
        public string UserMessage { get; set; }
    }
    [Serializable]
    [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
    public sealed class HttpException : Exception
    {
        public HttpException(HttpStatusCode httpStatusCode)
            : this(httpStatusCode, new HttpExceptionInfo())
        {
        }
        public HttpException(HttpStatusCode httpStatusCode, HttpExceptionInfo additionalInfo)
        {
            HttpStatusCode = httpStatusCode;
            ErrorCode = additionalInfo.ErrorCode ?? DefaultErrorCode;
            UserMessage = additionalInfo.UserMessage ?? DefaultUserMessage;
            CustomizeException();
        }
        public HttpException(HttpStatusCode httpStatusCode, string message)
            : this(httpStatusCode, message, new HttpExceptionInfo())
        {
        }
        public HttpException(HttpStatusCode httpStatusCode, string message, HttpExceptionInfo additionalInfo)
            : base(message)
        {
            HttpStatusCode = httpStatusCode;
            ErrorCode = additionalInfo.ErrorCode ?? DefaultErrorCode;
            UserMessage = additionalInfo.UserMessage ?? DefaultUserMessage;
            CustomizeException();
        }
        public HttpException(HttpStatusCode httpStatusCode, string message, Exception innerException)
            : this(httpStatusCode, message, innerException, new HttpExceptionInfo())
        {
        }
        public HttpException(HttpStatusCode httpStatusCode, string message, Exception innerException, HttpExceptionInfo additionalInfo)
            : base(message, innerException)
        {
            HttpStatusCode = httpStatusCode;
            ErrorCode = additionalInfo.ErrorCode ?? DefaultErrorCode;
            UserMessage = additionalInfo.UserMessage ?? DefaultUserMessage;
            CustomizeException();
        }
        public HttpStatusCode HttpStatusCode { get; }
        public object ErrorCode { get; }
        public static object DefaultErrorCode { get; set; } = "unspecified";
        public string UserMessage { get; }
        public static string DefaultUserMessage { get; set; } = "unspecified";
        private void CustomizeException()
        {
            HResult = (int) HttpStatusCode;
            Data.Add(nameof(HttpStatusCode), HttpStatusCode.ToString());
            Data.Add(nameof(ErrorCode), ErrorCode?.ToString());
            Data.Add(nameof(UserMessage), UserMessage);
        }
    }
}
//*** SourceCombiner -> original file Raise.cs ***
namespace PommaLabs.Thrower
{
    public static class Raise
    {
        #region Constants
#if NET35 || NET40
        internal const MethodImplOptions MethodImplOptions = default(System.Runtime.CompilerServices.MethodImplOptions);
#else
        internal const MethodImplOptions MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining;
#endif
        #endregion Constants
        #region System
        public static ArgumentExceptionHandler ArgumentException { get; } = new ArgumentExceptionHandler();
        public static ArgumentNullExceptionHandler ArgumentNullException { get; } = new ArgumentNullExceptionHandler();
        public static ArgumentOutOfRangeExceptionHandler ArgumentOutOfRangeException { get; } = new ArgumentOutOfRangeExceptionHandler();
        public static IndexOutOfRangeExceptionHandler IndexOutOfRangeException { get; } = new IndexOutOfRangeExceptionHandler();
        public static InvalidCastExceptionHandler InvalidCastException { get; } = new InvalidCastExceptionHandler();
        public static InvalidOperationExceptionHandler InvalidOperationException { get; } = new InvalidOperationExceptionHandler();
        public static NotSupportedExceptionHandler NotSupportedException { get; } = new NotSupportedExceptionHandler();
        public static ObjectDisposedExceptionHandler ObjectDisposedException { get; } = new ObjectDisposedExceptionHandler();
        #endregion System
        #region System.IO
#if !(NETSTD10 || NETSTD11)
        public static DirectoryNotFoundExceptionHandler DirectoryNotFoundException { get; } = new DirectoryNotFoundExceptionHandler();
#endif
        public static FileNotFoundExceptionHandler FileNotFoundException { get; } = new FileNotFoundExceptionHandler();
        public static InvalidDataExceptionHandler InvalidDataException { get; } = new InvalidDataExceptionHandler();
        public static IOExceptionHandler IOException { get; } = new IOExceptionHandler();
        #endregion System.IO
        #region System.Net
        public static HttpExceptionHandler HttpException { get; } = new HttpExceptionHandler();
        #endregion System.Net
    }
}
//*** SourceCombiner -> original file RaiseGeneric.cs ***
namespace PommaLabs.Thrower
{
    public abstract class RaiseBase
    {
        protected static readonly object[] NoCtorParams = new object[0];
        protected static readonly Type[] NoCtorTypes = new Type[0];
        protected static readonly Type[] StrExCtorTypes = { typeof(string), typeof(Exception) };
        protected static readonly Type[] StrCtorType = { typeof(string) };
    }
    public sealed partial class Raise<TEx> : RaiseBase where TEx : Exception
    {
        private static readonly bool ExTypeIsAbstract = PortableTypeInfo.IsAbstract(typeof(TEx));
        private static readonly ConstructorInfo NoArgsCtor = GetCtor(NoCtorTypes);
        private static readonly ConstructorInfo MsgCtor = GetCtor(StrExCtorTypes) ?? GetCtor(StrCtorType);
        private static readonly int MsgArgCount = (MsgCtor == null) ? 0 : MsgCtor.GetParameters().Length;
        private Raise()
        {
            throw new InvalidOperationException("This class should not be instantiated");
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static void If(bool cond)
        {
            if (cond)
            {
                DoThrow();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static void If(bool cond, string message)
        {
            if (cond)
            {
                DoThrow(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static void If(bool cond, object firstParam, params object[] otherParams)
        {
            if (cond)
            {
                DoThrow(firstParam, otherParams);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static void IfNot(bool cond)
        {
            if (!cond)
            {
                DoThrow();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static void IfNot(bool cond, string message)
        {
            if (!cond)
            {
                DoThrow(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static void IfNot(bool cond, object firstParam, params object[] otherParams)
        {
            if (!cond)
            {
                DoThrow(firstParam, otherParams);
            }
        }
        #region Private methods
        private static ConstructorInfo GetCtor(IList<Type> ctorTypes)
        {
            return (from c in PortableTypeInfo.GetConstructors(typeof(TEx))
                    let args = c.GetParameters()
                    let zipArgs = MyZip(args, ctorTypes, (argType, ctorType) => new { argType, ctorType })
                    where args.Length == ctorTypes.Count &&
                          (c.IsPublic || c.IsAssembly) &&
                          zipArgs.All(t => ReferenceEquals(t.argType.ParameterType, t.ctorType))
                    select c).FirstOrDefault();
        }
        private static IEnumerable<TResult> MyZip<TFirst, TSecond, TResult>(IEnumerable<TFirst> first, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
        {
            Raise.ArgumentNullException.IfIsNull(first, nameof(first));
            Raise.ArgumentNullException.IfIsNull(second, nameof(second));
            Raise.ArgumentNullException.IfIsNull(resultSelector, nameof(resultSelector));
            using (IEnumerator<TFirst> e1 = first.GetEnumerator())
            using (IEnumerator<TSecond> e2 = second.GetEnumerator())
            {
                while (e1.MoveNext() && e2.MoveNext())
                {
                    yield return resultSelector(e1.Current, e2.Current);
                }
            }
        }
        private static void DoThrow()
        {
            if (ExTypeIsAbstract)
            {
                throw ThrowerException.AbstractEx;
            }
            if (NoArgsCtor == null)
            {
                throw ThrowerException.MissingNoParamsCtorEx;
            }
            throw (TEx) NoArgsCtor.Invoke(NoCtorParams);
        }
        private static void DoThrow(string message)
        {
            if (ExTypeIsAbstract)
            {
                throw ThrowerException.AbstractEx;
            }
            if (MsgCtor == null)
            {
                throw ExTypeIsAbstract ? ThrowerException.AbstractEx : ThrowerException.MissingMsgCtorEx;
            }
            var messageArgs = new object[MsgArgCount];
            messageArgs[0] = message;
            throw (TEx) MsgCtor.Invoke(messageArgs);
        }
        private static void DoThrow(object firstParam, object[] otherParams)
        {
            if (ExTypeIsAbstract)
            {
                throw ThrowerException.AbstractEx;
            }
            if (firstParam == null)
            {
                throw ThrowerException.NullArgEx;
            }
            var paramCount = 1 + otherParams?.Length ?? 0;
            var ctorParams = new object[paramCount];
            ctorParams[0] = firstParam;
            var ctorTypes = new Type[paramCount];
            ctorTypes[0] = firstParam.GetType();
            if (paramCount > 1)
            {
                for (var i = 0; i < otherParams.Length; ++i)
                {
                    var p = otherParams[i];
                    if (p == null)
                    {
                        throw ThrowerException.NullArgEx;
                    }
                    ctorParams[i + 1] = p;
                    ctorTypes[i + 1] = p.GetType();
                }
            }
            var ctor = GetCtor(ctorTypes);
            if (ctor == null)
            {
                DoThrow();
            }
            throw (TEx) ctor.Invoke(ctorParams);
        }
        #endregion Private methods
    }
}
//*** SourceCombiner -> original file ThrowerException.cs ***
namespace PommaLabs.Thrower
{
    [Serializable]
    [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
    public sealed class ThrowerException : Exception
    {
        [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
        private ThrowerException(string message)
            : base(message)
        {
        }
        internal static ThrowerException AbstractEx => new ThrowerException("Given exception type is abstract");
        internal static ThrowerException MissingNoParamsCtorEx => new ThrowerException("Given exception type has no parameterless constructor");
        internal static ThrowerException MissingMsgCtorEx => new ThrowerException("Given exception type has not a valid message constructor");
        internal static ThrowerException NullArgEx => new ThrowerException("One of given exception parameters is null, exception constructor inference cannot work");
    }
}
//*** SourceCombiner -> original file ArgumentExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class ArgumentExceptionHandler
    {
        #region If
        private const string DefaultIfMessage = "Argument is not valid";
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition)
        {
            if (condition)
            {
                throw new ArgumentException(DefaultIfMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName, string message = null)
        {
            if (condition)
            {
                throw new ArgumentException(message ?? DefaultIfMessage, argumentName);
            }
        }
        #endregion If
        #region IfNot
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition)
        {
            if (!condition)
            {
                throw new ArgumentException(DefaultIfMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName, string message = null)
        {
            if (!condition)
            {
                throw new ArgumentException(message ?? DefaultIfMessage, argumentName);
            }
        }
        #endregion IfNot
        #region IfIsEqualTo
        private const string DefaultIfIsEqualMessage = "Argument is equal to given value";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (Equals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsEqualMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (Equals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsEqualMessage, argumentName);
            }
        }
        #endregion IfIsEqualTo
        #region IfIsNotEqualTo
        private const string DefaultIfIsNotEqualMessage = "Argument is not equal to given value";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (!Equals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsNotEqualMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqualTo<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (!Equals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsNotEqualMessage, argumentName);
            }
        }
        #endregion IfIsNotEqualTo
        #region IfIsSameAs
        private const string DefaultIfIsSameMessage = "Argument is the same object as given value";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsSameMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsSameMessage, argumentName);
            }
        }
        #endregion IfIsSameAs
        #region IfIsNotSameAs
        private const string DefaultIfIsNotSameMessage = "Argument is not the same object as given value";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand)
        {
            if (!ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(DefaultIfIsNotSameMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotSameAs<TArg1, TArg2>(TArg1 argument, TArg2 comparand, string argumentName, string message = null)
        {
            if (!ReferenceEquals(argument, comparand))
            {
                throw new ArgumentException(message ?? DefaultIfIsNotSameMessage, argumentName);
            }
        }
        #endregion IfIsNotSameAs
        #region IfIsNotValid
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValid<TArg>(TArg argument)
        {
            IList<ValidationError> validationErrors;
            if (!ObjectValidator.Validate(argument, out validationErrors))
            {
                throw new ArgumentException(ObjectValidator.FormatValidationErrors(validationErrors, null));
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValid<TArg>(TArg argument, string argumentName, string message = null)
        {
            IList<ValidationError> validationErrors;
            if (!ObjectValidator.Validate(argument, out validationErrors))
            {
                throw new ArgumentException(ObjectValidator.FormatValidationErrors(validationErrors, message), argumentName);
            }
        }
        #endregion IfIsNotValid
        #region IfIsNotValidEnum
        private const string DefaultIfIsNotValidEnumMessage = "Enumeration \"{0}\" is not a valid value for type \"{1}\"";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum argument)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum argument, string argumentName, string message = null)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum? argument)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum<TEnum>(TEnum? argument, string argumentName, string message = null)
            where TEnum : struct
        {
            if (!EnumerationValidator.Validate(argument))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEnumMessage, argument, typeof(TEnum).Name);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum(Type enumType, object argument)
        {
            if (!EnumerationValidator.Validate(enumType, argument))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEnumMessage, argument, enumType.Name);
                throw new ArgumentException(exceptionMsg);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEnum(Type enumType, object argument, string argumentName, string message = null)
        {
            if (!EnumerationValidator.Validate(enumType, argument))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEnumMessage, argument, enumType.Name);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }
        #endregion IfIsNotValidEnum
        #region IfIsNotValidEmailAddress
        private const string DefaultIfIsNotValidEmailAddressMessage = "String \"{0}\" is not a valid email address";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress)
        {
            if (!EmailAddressValidator.Validate(emailAddress))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress, EmailAddressValidator.Options validatorOptions)
        {
            if (!EmailAddressValidator.Validate(emailAddress, validatorOptions))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress, string argumentName, string message = null)
        {
            if (!EmailAddressValidator.Validate(emailAddress))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidEmailAddress(string emailAddress, string argumentName, EmailAddressValidator.Options validatorOptions, string message = null)
        {
            if (!EmailAddressValidator.Validate(emailAddress, validatorOptions))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidEmailAddressMessage, emailAddress);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }
        #endregion IfIsNotValidEmailAddress
        #region IfIsNotValidPhoneNumber
        private const string DefaultIfIsNotValidPhoneNumberMessage = "String \"{0}\" is not a valid phone number";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidPhoneNumber(string phoneNumber)
        {
            if (!PhoneNumberValidator.Validate(phoneNumber))
            {
                var exceptionMsg = string.Format(DefaultIfIsNotValidPhoneNumberMessage, phoneNumber);
                throw new ArgumentException(exceptionMsg);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotValidPhoneNumber(string phoneNumber, string argumentName, string message = null)
        {
            if (!PhoneNumberValidator.Validate(phoneNumber))
            {
                var exceptionMsg = message ?? string.Format(DefaultIfIsNotValidPhoneNumberMessage, phoneNumber);
                throw new ArgumentException(exceptionMsg, argumentName);
            }
        }
        #endregion IfIsNotValidPhoneNumber
        #region String validation
        private const string StringIsNullOrEmptyMessage = "Argument cannot be a null or empty string";
        private const string StringIsNullOrWhiteSpaceMessage = "Argument cannot be a null, empty or blank string";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty(string value)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value))
            {
                throw new ArgumentException(StringIsNullOrEmptyMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty(string value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value))
            {
                throw new ArgumentException(message ?? StringIsNullOrEmptyMessage, argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrWhiteSpace(string value)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value.Trim()))
            {
                throw new ArgumentException(StringIsNullOrWhiteSpaceMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrWhiteSpace(string value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || string.Empty.Equals(value.Trim()))
            {
                throw new ArgumentException(message ?? StringIsNullOrWhiteSpaceMessage, argumentName);
            }
        }
        #endregion String validation
        #region Collection and enumerable validation
        internal const string CollectionIsNullOrEmptyMessage = "Argument cannot be a null or empty collection";
        internal const string EnumerableIsNullOrEmptyMessage = "Argument cannot be a null or empty enumerable";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(ICollection<TItem> value)
        {
            if (ReferenceEquals(value, null) || value.Count == 0)
            {
                throw new ArgumentException(CollectionIsNullOrEmptyMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(ICollection<TItem> value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || value.Count == 0)
            {
                throw new ArgumentException(message ?? CollectionIsNullOrEmptyMessage, argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(IEnumerable<TItem> value)
        {
            if (ReferenceEquals(value, null) || !value.GetEnumerator().MoveNext())
            {
                throw new ArgumentException(CollectionIsNullOrEmptyMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNullOrEmpty<TItem>(IEnumerable<TItem> value, string argumentName, string message = null)
        {
            if (ReferenceEquals(value, null) || !value.GetEnumerator().MoveNext())
            {
                throw new ArgumentException(message ?? CollectionIsNullOrEmptyMessage, argumentName);
            }
        }
        #endregion Collection and enumerable validation
    }
}
//*** SourceCombiner -> original file ArgumentNullExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class ArgumentNullExceptionHandler
    {
        private const string DefaultMessage = "Argument, or a nested object, is null";
        #region If(Not)
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition)
        {
            if (condition)
            {
                throw new ArgumentNullException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName, string message = null)
        {
            if (condition)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition)
        {
            if (!condition)
            {
                throw new ArgumentNullException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName, string message = null)
        {
            if (!condition)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }
        #endregion If(Not)
        #region Classes
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg argument)
        {
            if (ReferenceEquals(argument, null))
            {
                throw new ArgumentNullException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg argument, string argumentName, string message = null)
        {
            if (ReferenceEquals(argument, null))
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }
        #endregion Classes
        #region Nullable structs
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg? argument)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(ref TArg? argument)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(TArg? argument, string argumentName, string message = null)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNull<TArg>(ref TArg? argument, string argumentName, string message = null)
            where TArg : struct
        {
            if (!argument.HasValue)
            {
                throw new ArgumentNullException(argumentName, message ?? DefaultMessage);
            }
        }
        #endregion Nullable structs
    }
}
//*** SourceCombiner -> original file ArgumentOutOfRangeExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class ArgumentOutOfRangeExceptionHandler
    {
        #region If
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName = null)
        {
            if (condition)
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, string argumentName, string message)
        {
            if (condition)
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }
        #endregion If
        #region IfNot
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName = null)
        {
            if (!condition)
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, string argumentName, string message)
        {
            if (!condition)
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }
        #endregion IfNot
        #region IfIsNaN
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNaN(double number, string argumentName = null)
        {
            if (double.IsNaN(number))
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNaN(double number, string argumentName, string message)
        {
            if (double.IsNaN(number))
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }
        #endregion IfIsNaN
        #region IfIsPositiveInfinity
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsPositiveInfinity(double number, string argumentName = null)
        {
            if (double.IsPositiveInfinity(number))
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsPositiveInfinity(double number, string argumentName, string message)
        {
            if (double.IsPositiveInfinity(number))
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }
        #endregion IfIsPositiveInfinity
        #region IfIsNegativeInfinity
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNegativeInfinity(double number, string argumentName = null)
        {
            if (double.IsNegativeInfinity(number))
            {
                throw string.IsNullOrEmpty(argumentName) ? new ArgumentOutOfRangeException() : new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNegativeInfinity(double number, string argumentName, string message)
        {
            if (double.IsNegativeInfinity(number))
            {
                throw new ArgumentOutOfRangeException(argumentName, message);
            }
        }
        #endregion IfIsNegativeInfinity
        #region Less - Without parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        #endregion Less - Without parameter name, without message
        #region Less - With parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        #endregion Less - With parameter name, without message
        #region Less - With parameter name, with message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        #endregion Less - With parameter name, with message
        #region LessEqual - Without parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        #endregion LessEqual - Without parameter name, without message
        #region LessEqual - With parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        #endregion LessEqual - With parameter name, without message
        #region LessEqual - With parameter name, with message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        #endregion LessEqual - With parameter name, with message
        #region Greater - Without parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        #endregion Greater - Without parameter name, without message
        #region Greater - With parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        #endregion Greater - With parameter name, without message
        #region Greater - With parameter name, with message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        #endregion Greater - With parameter name, with message
        #region GreaterEqual - Without parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        #endregion GreaterEqual - Without parameter name, without message
        #region GreaterEqual - With parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        #endregion GreaterEqual - With parameter name, without message
        #region GreaterEqual - With parameter name, with message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        #endregion GreaterEqual - With parameter name, with message
        #region Equal - Without parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        #endregion Equal - Without parameter name, without message
        #region Equal - With parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        #endregion Equal - With parameter name, without message
        #region Equal - With parameter name, with message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        #endregion Equal - With parameter name, with message
        #region NotEqual - Without parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException();
            }
        }
        #endregion NotEqual - Without parameter name, without message
        #region NotEqual - With parameter name, without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2, string argumentName)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2, string argumentName)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName);
            }
        }
        #endregion NotEqual - With parameter name, without message
        #region NotEqual - With parameter name, with message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2, string argumentName, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2, string argumentName, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new ArgumentOutOfRangeException(argumentName, argument1, message);
            }
        }
        #endregion NotEqual - With parameter name, with message
    }
}
//*** SourceCombiner -> original file GenericExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public abstract class GenericExceptionHandler<TException>
        where TException : Exception, new()
    {
        #region Abstract members
        protected abstract TException NewWithMessage(string message);
        #endregion Abstract members
        #region If (not)
        public void If(bool condition, string message = null)
        {
            if (condition)
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        public void IfNot(bool condition, string message = null)
        {
            if (!condition)
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        #endregion If (not)
        #region Reflection
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsAssignableFrom<TType>(object instance, string message = null)
        {
            if (ReferenceEquals(instance, null) || PortableTypeInfo.IsAssignableFrom(instance, typeof(TType)))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsNotAssignableFrom<TType>(object instance, string message = null)
        {
            if (!PortableTypeInfo.IsAssignableFrom(instance, typeof(TType)))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        public void IfIsAssignableFrom(object instance, Type type, string message = null)
        {
            if (PortableTypeInfo.IsAssignableFrom(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        public void IfIsNotAssignableFrom(object instance, Type type, string message = null)
        {
            if (ReferenceEquals(instance, null) || !PortableTypeInfo.IsAssignableFrom(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsInstanceOf<TType>(object instance, string message = null)
        {
            if (instance is TType)
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        [SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
        public void IfIsNotInstanceOf<TType>(object instance, string message = null)
        {
            if (!(instance is TType))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        public void IfIsInstanceOf(object instance, Type type, string message = null)
        {
            if (PortableTypeInfo.IsInstanceOf(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        public void IfIsNotInstanceOf(object instance, Type type, string message = null)
        {
            if (!PortableTypeInfo.IsInstanceOf(instance, type))
            {
                throw string.IsNullOrEmpty(message) ? new TException() : NewWithMessage(message);
            }
        }
        #endregion Reflection
    }
}
//*** SourceCombiner -> original file IndexOutOfRangeExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class IndexOutOfRangeExceptionHandler
    {
        #region Less - Without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        #endregion Less - Without message
        #region Less - With message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLess(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) < 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        #endregion Less - With message
        #region LessEqual - Without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        #endregion LessEqual - Without message
        #region LessEqual - With message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsLessOrEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) <= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        #endregion LessEqual - With message
        #region Greater - Without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        #endregion Greater - Without message
        #region Greater - With message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreater(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) > 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        #endregion Greater - With message
        #region GreaterEqual - Without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        #endregion GreaterEqual - Without message
        #region GreaterEqual - With message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsGreaterOrEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) >= 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        #endregion GreaterEqual - With message
        #region Equal - Without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        #endregion Equal - Without message
        #region Equal - With message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) == 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        #endregion Equal - With message
        #region NotEqual - Without message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException();
            }
        }
        #endregion NotEqual - Without message
        #region NotEqual - With message
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual<TArg>(TArg argument1, TArg argument2, string message)
            where TArg : IComparable<TArg>
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfIsNotEqual(IComparable argument1, IComparable argument2, string message)
        {
            if (ReferenceEquals(argument1, null) || argument1.CompareTo(argument2) != 0)
            {
                throw new IndexOutOfRangeException(message);
            }
        }
        #endregion NotEqual - With message
    }
}
//*** SourceCombiner -> original file InvalidCastExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class InvalidCastExceptionHandler : GenericExceptionHandler<InvalidCastException>
    {
        protected override InvalidCastException NewWithMessage(string message) => new InvalidCastException(message);
    }
}
//*** SourceCombiner -> original file InvalidOperationExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class InvalidOperationExceptionHandler : GenericExceptionHandler<InvalidOperationException>
    {
        protected override InvalidOperationException NewWithMessage(string message) => new InvalidOperationException(message);
    }
}
//*** SourceCombiner -> original file NotSupportedExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class NotSupportedExceptionHandler : GenericExceptionHandler<NotSupportedException>
    {
        protected override NotSupportedException NewWithMessage(string message) => new NotSupportedException(message);
    }
}
//*** SourceCombiner -> original file ObjectDisposedExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers
{
    public sealed class ObjectDisposedExceptionHandler
    {
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool disposed, string objectName, string message = null)
        {
            if (disposed)
            {
                throw string.IsNullOrEmpty(message) ? new ObjectDisposedException(objectName) : new ObjectDisposedException(objectName, message);
            }
        }
    }
}
//*** SourceCombiner -> original file DirectoryNotFoundExceptionHandler.cs ***
#if !(NETSTD10 || NETSTD11)
namespace PommaLabs.Thrower.ExceptionHandlers.IO
{
    public sealed class DirectoryNotFoundExceptionHandler : GenericExceptionHandler<DirectoryNotFoundException>
    {
        protected override DirectoryNotFoundException NewWithMessage(string message) => new DirectoryNotFoundException(message);
        public static string DefaultNotExistsMessage { get; } = "Specified directory does not exist";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNotExists(string directoryPath, string message = null)
        {
            if (!Directory.Exists(directoryPath))
            {
                var exMsg = $@"{message ?? DefaultNotExistsMessage} - ""{directoryPath}""";
                throw new DirectoryNotFoundException(exMsg);
            }
        }
    }
}
#endif
//*** SourceCombiner -> original file FileNotFoundExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers.IO
{
    public sealed class FileNotFoundExceptionHandler : GenericExceptionHandler<FileNotFoundException>
    {
        protected override FileNotFoundException NewWithMessage(string message) => new FileNotFoundException(message);
#if !(NETSTD10 || NETSTD11)
        public static string DefaultNotExistsMessage { get; } = "Specified file does not exist or the caller does not have sufficient permissions to read the specified file";
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNotExists(string filePath, string message = null)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException(message ?? DefaultNotExistsMessage, filePath);
            }
        }
#endif
    }
}
//*** SourceCombiner -> original file InvalidDataExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers.IO
{
    public sealed class InvalidDataExceptionHandler : GenericExceptionHandler<InvalidDataException>
    {
        protected override InvalidDataException NewWithMessage(string message) => new InvalidDataException(message);
    }
}
//*** SourceCombiner -> original file IOExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers.IO
{
    public sealed class IOExceptionHandler : GenericExceptionHandler<IOException>
    {
        protected override IOException NewWithMessage(string message) => new IOException(message);
    }
}
//*** SourceCombiner -> original file HttpExceptionHandler.cs ***
namespace PommaLabs.Thrower.ExceptionHandlers.Net
{
    public sealed class HttpExceptionHandler
    {
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, HttpStatusCode httpStatusCode, string message = null)
        {
            if (condition)
            {
                throw string.IsNullOrEmpty(message) ? new HttpException(httpStatusCode) : new HttpException(httpStatusCode, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void If(bool condition, HttpStatusCode httpStatusCode, string message, HttpExceptionInfo additionalInfo)
        {
            if (condition)
            {
                throw new HttpException(httpStatusCode, message, additionalInfo);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, HttpStatusCode httpStatusCode, string message = null)
        {
            if (!condition)
            {
                throw string.IsNullOrEmpty(message) ? new HttpException(httpStatusCode) : new HttpException(httpStatusCode, message);
            }
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public void IfNot(bool condition, HttpStatusCode httpStatusCode, string message, HttpExceptionInfo additionalInfo)
        {
            if (!condition)
            {
                throw new HttpException(httpStatusCode, message, additionalInfo);
            }
        }
    }
}
//*** SourceCombiner -> original file EnvironmentExtensions.cs ***
namespace PommaLabs.Thrower.Goodies
{
    public static class EnvironmentExtensions
    {
        private static readonly string[] MapPathStarts = { "~//", "~\\\\", "~/", "~\\", "~" };
        public static bool AppIsRunningOnAspNet
        {
            get
            {
#if !(NETSTD10 || NETSTD11 || NETSTD13)
                return "web.config".Equals(Path.GetFileName(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile), StringComparison.OrdinalIgnoreCase);
#else
#endif
            }
        }
        public static string MapPath(string path)
        {
            Raise.ArgumentNullException.IfIsNull(path, nameof(path));
            if (Path.IsPathRooted(path))
            {
                return path;
            }
            var basePath = GetBaseDirectory();
            var trimmedPath = path.Trim();
            foreach (var start in MapPathStarts)
            {
                if (trimmedPath.StartsWith(start, StringComparison.Ordinal))
                {
                    trimmedPath = trimmedPath.Substring(start.Length, trimmedPath.Length - start.Length);
                    break;
                }
            }
            return Path.Combine(basePath, trimmedPath);
        }
        private static string GetBaseDirectory()
        {
#if (NETSTD10 || NETSTD11)
            return string.Empty;
#elif NETSTD13
            return AppContext.BaseDirectory;
#else
            return AppDomain.CurrentDomain.BaseDirectory;
#endif
        }
    }
}
//*** SourceCombiner -> original file EquatableObject.cs ***
namespace PommaLabs.Thrower.Goodies
{
    [Serializable]
    public abstract class EquatableObject<T> : FormattableObject, IEquatable<T>
        where T : EquatableObject<T>
    {
        public const int HashCodeSeed = 397;
        #region Abstract Methods
        protected abstract IEnumerable<object> GetIdentifyingMembers();
        #endregion Abstract Methods
        #region Object Methods
        public virtual bool Equals(T other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            return System.Linq.Enumerable.SequenceEqual(GetIdentifyingMembers(), other.GetIdentifyingMembers());
        }
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj.GetType() != GetType()) return false;
            return Equals(obj as T);
        }
        public override int GetHashCode()
        {
            unchecked
            {
                return System.Linq.Enumerable.Aggregate(GetIdentifyingMembers(), HashCodeSeed, ComputeHashCode);
            }
        }
        #endregion Object Methods
        #region Equality Operators
        public static bool operator ==(EquatableObject<T> left, EquatableObject<T> right) => Equals(left, right);
        public static bool operator !=(EquatableObject<T> left, EquatableObject<T> right) => !Equals(left, right);
        #endregion Equality Operators
        #region Private Methods
        private static int ComputeHashCode(int hashCode, object obj) => (obj == null) ? hashCode : (hashCode ^ obj.GetHashCode());
        #endregion Private Methods
    }
}
//*** SourceCombiner -> original file FormattableObject.cs ***
namespace PommaLabs.Thrower.Goodies
{
    [Serializable]
    public abstract class FormattableObject
    {
        #region Abstract Methods
        protected abstract IEnumerable<KeyValuePair<string, object>> GetFormattingMembers();
        #endregion Abstract Methods
        #region Object Methods
        public override string ToString() => string.Join(", ", Enumerable.Select(GetFormattingMembers(), ToString).ToArray());
        #endregion Object Methods
        #region Static Methods
        public static string ToString(KeyValuePair<string, object> pair)
        {
            var k = pair.Key;
            var v = pair.Value;
            if (v == null)
            {
                return $"{k}: null";
            }
            var s = v as string;
            if (s != null)
            {
                return $"{k}: \"{s}\"";
            }
            var t = v.GetType();
            if (PortableTypeInfo.IsPrimitive(t))
            {
                return $"{k}: {v}";
            }
            return $"{k}: {{{v}}}";
        }
        #endregion Static Methods
    }
}
//*** SourceCombiner -> original file StringExtensions.cs ***
namespace PommaLabs.Thrower.Goodies
{
    public static class StringExtensions
    {
        #region String manipulation
        private static readonly IList<string> NoSubstrings = new string[0];
        public static string Truncate(this string str, int maxLength)
        {
            if (string.IsNullOrEmpty(str))
            {
                return str;
            }
            maxLength = Math.Max(0, maxLength);
            return (str.Length < maxLength ? str : str.Substring(0, maxLength));
        }
        public static IList<string> SplitAndTrim(this string str, params char[] separator)
        {
            if (string.IsNullOrEmpty(str))
            {
                return NoSubstrings;
            }
            var split = str.Split(separator, StringSplitOptions.RemoveEmptyEntries);
            if (split.Length == 0)
            {
                return NoSubstrings;
            }
            var result = new string[split.Length];
            for (var i = 0; i < split.Length; ++i)
            {
                result[i] = split[i].Trim();
            }
            return result;
        }
        public static IList<string> SplitAndTrim(this string str, params string[] separator)
        {
            if (string.IsNullOrEmpty(str))
            {
                return NoSubstrings;
            }
            var split = str.Split(separator, StringSplitOptions.RemoveEmptyEntries);
            if (split.Length == 0)
            {
                return NoSubstrings;
            }
            var result = new string[split.Length];
            for (var i = 0; i < split.Length; ++i)
            {
                result[i] = split[i].Trim();
            }
            return result;
        }
        #endregion String manipulation
        #region Type conversion
        public static TEnum ToEnum<TEnum>(this string enumString, bool ignoreCase)
            where TEnum : struct
        {
            var enumType = typeof(TEnum);
            Raise.InvalidOperationException.IfNot(PortableTypeInfo.IsEnum(enumType), "Given type is not an enumeration");
#if NET35
            var enumValue = Enum.Parse(enumType, enumString, ignoreCase);
            if (Enum.IsDefined(enumType, enumValue))
            {
                return (TEnum) enumValue;
            }
#else
            TEnum enumValue;
            if (Enum.TryParse(enumString, ignoreCase, out enumValue))
            {
                return enumValue;
            }
#endif
            throw new ArgumentException($"Given value is not available for {enumType.Name}", nameof(enumString));
        }
        public static TEnum ToEnum<TEnum>(this string enumString) where TEnum : struct => ToEnum<TEnum>(enumString, true);
        public static TEnum ToEnumOrDefault<TEnum>(this string enumString, bool ignoreCase)
            where TEnum : struct
        {
            var enumType = typeof(TEnum);
            Raise.InvalidOperationException.IfNot(PortableTypeInfo.IsEnum(enumType), "Given type is not an enumeration");
#if NET35
            var enumValue = Enum.Parse(enumType, enumString, ignoreCase);
            if (Enum.IsDefined(enumType, enumValue))
            {
                return (TEnum) enumValue;
            }
#else
            TEnum enumValue;
            if (Enum.TryParse(enumString, ignoreCase, out enumValue))
            {
                return enumValue;
            }
#endif
            return default(TEnum);
        }
        public static TEnum ToEnumOrDefault<TEnum>(this string enumString) where TEnum : struct => ToEnumOrDefault<TEnum>(enumString, true);
        #endregion Type conversion
    }
}
//*** SourceCombiner -> original file PortableSerializationAttributes.cs ***
#if (NETSTD10 || NETSTD11)
namespace System
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = false)]
    public sealed class SerializableAttribute : Attribute
    {
    }
    [AttributeUsage(AttributeTargets.Field, Inherited = false)]
    public sealed class NonSerializedAttribute : Attribute
    {
    }
}
#endif
//*** SourceCombiner -> original file PortableTypeInfo.cs ***
namespace PommaLabs.Thrower.Reflection
{
    [SecuritySafeCritical]
    public static class PortableTypeInfo
    {
#if !(NETSTD10 || NETSTD11)
        internal const BindingFlags PublicAndPrivateInstanceFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;
        internal const BindingFlags PublicInstanceFlags = BindingFlags.Public | BindingFlags.Instance;
#endif
        private static readonly object[] EmptyObjectArray = new object[0];
        public static Type[] EmptyTypes { get; } = new Type[0];
        #region GetTypeAssembly
        [MethodImpl(Raise.MethodImplOptions)]
        public static Assembly GetTypeAssembly(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).Assembly;
#else
            return type.Assembly;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static Assembly GetTypeAssembly<T>() => GetTypeAssembly(typeof(T));
        #endregion GetTypeAssembly
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Attribute> GetCustomAttributes(Type type, bool inherit)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).GetCustomAttributes().ToArray();
#else
            return type.GetCustomAttributes(inherit).Cast<Attribute>().ToArray();
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Attribute> GetCustomAttributes(MemberInfo memberInfo, bool inherit)
        {
#if (NETSTD10 || NETSTD11)
            return memberInfo.GetCustomAttributes(inherit).ToArray();
#else
            return memberInfo.GetCustomAttributes(inherit).Cast<Attribute>().ToArray();
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<ConstructorInfo> GetConstructors(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).DeclaredConstructors.ToArray();
#else
            return type.GetConstructors(PublicAndPrivateInstanceFlags);
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<ConstructorInfo> GetConstructors<T>() => GetConstructors(typeof(T));
        [MethodImpl(Raise.MethodImplOptions)]
        public static Type GetBaseType(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).BaseType;
#else
            return type.BaseType;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static Type GetGenericTypeDefinition(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).GetGenericTypeDefinition();
#else
            return type.GetGenericTypeDefinition();
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Type> GetGenericTypeArguments(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).GenericTypeArguments;
#else
            return type.GetGenericArguments();
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<Type> GetInterfaces(Type type)
        {
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).ImplementedInterfaces.ToArray();
#else
            return type.GetInterfaces();
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<PropertyInfo> GetPublicProperties(Type type)
        {
#if (NETSTD10 || NETSTD11)
            var properties = new List<PropertyInfo>();
            while (type != null)
            {
                var typeInfo = IntrospectionExtensions.GetTypeInfo(type);
                properties.AddRange(typeInfo.DeclaredProperties.Where(p => p.GetMethod.IsPublic));
                type = typeInfo.BaseType;
            }
            return properties;
#else
            return type.GetProperties(PublicInstanceFlags);
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static IList<PropertyInfo> GetPublicProperties<T>() => GetPublicProperties(typeof(T));
        #region GetPublicPropertyValue
        [MethodImpl(Raise.MethodImplOptions)]
        public static object GetPublicPropertyValue(object instance, string propertyName)
        {
            Raise.ArgumentNullException.IfIsNull(instance, nameof(instance), "Instance cannot be null");
            Raise.ArgumentException.IfIsNullOrWhiteSpace(propertyName, nameof(propertyName), "Given property cannot be null, empty or blank");
#if !(NETSTD10 || NETSTD11)
            return FastMember.ObjectAccessor.Create(instance)[propertyName];
#else
            var propertyInfo = GetPublicProperties(instance.GetType()).Single(p => p.Name == propertyName);
            return GetPublicPropertyValue(instance, propertyInfo);
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static TValue GetPublicPropertyValue<TValue>(object instance, string propertyName) => (TValue) GetPublicPropertyValue(instance, propertyName);
        [MethodImpl(Raise.MethodImplOptions)]
        public static object GetPublicPropertyValue(object instance, PropertyInfo propertyInfo)
        {
            Raise.ArgumentNullException.IfIsNull(instance, nameof(instance), "Instance cannot be null");
            Raise.ArgumentException.IfNot(propertyInfo.CanRead, nameof(propertyInfo), "Given property cannot be read");
            return propertyInfo.GetValue(instance, EmptyObjectArray);
        }
#if !(NETSTD10 || NETSTD11)
        [MethodImpl(Raise.MethodImplOptions)]
        public static object GetPublicPropertyValue(FastMember.TypeAccessor typeAccessor, object instance, PropertyInfo propertyInfo)
        {
            Raise.ArgumentNullException.IfIsNull(instance, nameof(instance), "Instance cannot be null");
            Raise.ArgumentException.IfNot(propertyInfo.CanRead, nameof(propertyInfo), "Given property cannot be read");
            return typeAccessor[instance, propertyInfo.Name];
        }
#endif
        #endregion GetPublicPropertyValue
        #region IsAbstract
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsAbstract(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsAbstract;
#else
            return type.IsAbstract;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsAbstract<T>() => IsAbstract(typeof(T));
        #endregion IsAbstract
        #region IsClass
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsClass(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsClass;
#else
            return type.IsClass;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsClass<T>() => IsClass(typeof(T));
        #endregion IsClass
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsAssignableFrom(object obj, Type type)
        {
            if (ReferenceEquals(obj, null) || ReferenceEquals(type, null))
            {
                return false;
            }
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(obj.GetType()).IsAssignableFrom(IntrospectionExtensions.GetTypeInfo(type));
#else
            return obj.GetType().IsAssignableFrom(type);
#endif
        }
        #region IsEnum
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsEnum(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsEnum;
#else
            return type.IsEnum;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsEnum<T>() => IsEnum(typeof(T));
        #endregion IsEnum
        #region IsGenericType
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericType(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsGenericType;
#else
            return type.IsGenericType;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericType<T>() => IsGenericType(typeof(T));
        #endregion IsGenericType
        #region IsGenericTypeDefinition
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericTypeDefinition(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsGenericTypeDefinition;
#else
            return type.IsGenericTypeDefinition;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsGenericTypeDefinition<T>() => IsGenericTypeDefinition(typeof(T));
        #endregion IsGenericTypeDefinition
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsInstanceOf(object obj, Type type)
        {
            if (ReferenceEquals(obj, null) || ReferenceEquals(type, null))
            {
                return false;
            }
#if (NETSTD10 || NETSTD11)
            return IntrospectionExtensions.GetTypeInfo(type).IsAssignableFrom(IntrospectionExtensions.GetTypeInfo(obj.GetType()));
#else
            return type.IsInstanceOfType(obj);
#endif
        }
        #region IsInterface
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsInterface(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsInterface;
#else
            return type.IsInterface;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsInterface<T>() => IsInterface(typeof(T));
        #endregion IsInterface
        #region IsPrimitive
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPrimitive(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsPrimitive;
#else
            return type.IsPrimitive;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPrimitive<T>() => IsPrimitive(typeof(T));
        #endregion IsPrimitive
        #region IsValueType
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsValueType(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return IntrospectionExtensions.GetTypeInfo(type).IsValueType;
#else
            return type.IsValueType;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsValueType<T>() => IsValueType(typeof(T));
        #endregion IsValueType
        #region IsPublic
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPublic(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return type.GetTypeInfo().IsPublic;
#else
            return type.IsPublic;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsPublic<T>() => IsPublic(typeof(T));
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsNestedPublic(Type type)
        {
#if (NETSTD10 || NETSTD11 || NETSTD13)
            return type.GetTypeInfo().IsNestedPublic;
#else
            return type.IsNestedPublic;
#endif
        }
        [MethodImpl(Raise.MethodImplOptions)]
        public static bool IsNestedPublic<T>() => IsNestedPublic(typeof(T));
        #endregion IsPublic
        #region CastTo
        public static class CastTo<T>
        {
            [MethodImpl(Raise.MethodImplOptions)]
            public static T From<S>(S s)
            {
                return Cache<S>.caster(s);
            }
            private static class Cache<S>
            {
                public static readonly Func<S, T> caster = Get();
                private static Func<S, T> Get()
                {
                    var p = Expression.Parameter(typeof(S), "s");
                    var c = Expression.ConvertChecked(p, typeof(T));
                    return Expression.Lambda<Func<S, T>>(c, p).Compile();
                }
            }
        }
        #endregion CastTo
    }
}
//*** SourceCombiner -> original file CallSiteCache.cs ***
#if !(NET35 || NETSTD10 || NETSTD11)
namespace PommaLabs.Thrower.Reflection.FastMember
{
    internal static class CallSiteCache
    {
        private static readonly Hashtable Getters = new Hashtable(), Setters = new Hashtable();
        internal static object GetValue(string name, object target)
        {
            var callSite = (CallSite<Func<CallSite, object, object>>) Getters[name];
            if (callSite == null)
            {
                var newSite = CallSite<Func<CallSite, object, object>>.Create(Binder.GetMember(CSharpBinderFlags.None, name, typeof(CallSiteCache), new CSharpArgumentInfo[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }));
                lock (Getters)
                {
                    callSite = (CallSite<Func<CallSite, object, object>>) Getters[name];
                    if (callSite == null)
                    {
                        Getters[name] = callSite = newSite;
                    }
                }
            }
            return callSite.Target(callSite, target);
        }
        internal static void SetValue(string name, object target, object value)
        {
            var callSite = (CallSite<Func<CallSite, object, object, object>>) Setters[name];
            if (callSite == null)
            {
                var newSite = CallSite<Func<CallSite, object, object, object>>.Create(Binder.SetMember(CSharpBinderFlags.None, name, typeof(CallSiteCache), new CSharpArgumentInfo[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType, null) }));
                lock (Setters)
                {
                    callSite = (CallSite<Func<CallSite, object, object, object>>) Setters[name];
                    if (callSite == null)
                    {
                        Setters[name] = callSite = newSite;
                    }
                }
            }
            callSite.Target(callSite, target, value);
        }
    }
}
#endif
//*** SourceCombiner -> original file MemberSet.cs ***
#if !(NETSTD10 || NETSTD11)
#if !NET20
#endif
namespace PommaLabs.Thrower.Reflection.FastMember
{
    [SecuritySafeCritical]
    public sealed class MemberSet : IEnumerable<Member>, IList<Member>
    {
        private Member[] members;
        internal MemberSet(Type type)
        {
            const BindingFlags publicInstance = BindingFlags.Public | BindingFlags.Instance;
#if NET20
            var properties = new List<MemberInfo>(type.GetProperties(publicInstance));
            properties.AddRange(new List<MemberInfo>(type.GetFields(publicInstance)));
            properties.Sort((p1, p2) => p1.Name.CompareTo(p2.Name));
            members = properties.ConvertAll<Member>(mi => new Member(mi)).ToArray();
#else
            members = type
                .GetProperties(publicInstance)
                .Cast<MemberInfo>()
                .Concat(type.GetFields(publicInstance).Cast<MemberInfo>())
                .OrderBy(x => x.Name)
                .Select(member => new Member(member))
                .ToArray();
#endif
        }
        public IEnumerator<Member> GetEnumerator()
        {
            foreach (var member in members) yield return member;
        }
        public Member this[int index] => members[index];
        public int Count => members.Length;
        Member IList<Member>.this[int index]
        {
            get { return members[index]; }
            set { throw new NotSupportedException(); }
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
        bool ICollection<Member>.Remove(Member item)
        {
            throw new NotSupportedException();
        }
        void ICollection<Member>.Add(Member item)
        {
            throw new NotSupportedException();
        }
        void ICollection<Member>.Clear()
        {
            throw new NotSupportedException();
        }
        void IList<Member>.RemoveAt(int index)
        {
            throw new NotSupportedException();
        }
        void IList<Member>.Insert(int index, Member item)
        {
            throw new NotSupportedException();
        }
        bool ICollection<Member>.Contains(Member item)
        {
#if NET20
            foreach (var _item in members)
            {
                if (item == _item)
                {
                    return true;
                }
            }
            return false;
#else
            return members.Contains(item);
#endif
        }
        void ICollection<Member>.CopyTo(Member[] array, int arrayIndex)
        {
            members.CopyTo(array, arrayIndex);
        }
        bool ICollection<Member>.IsReadOnly => true;
        int IList<Member>.IndexOf(Member member) => Array.IndexOf<Member>(members, member);
    }
    public sealed class Member
    {
        private readonly MemberInfo member;
        internal Member(MemberInfo member)
        {
            this.member = member;
        }
        public string Name => member.Name;
        public Type Type
        {
            get
            {
                if (member is FieldInfo) return ((FieldInfo) member).FieldType;
                if (member is PropertyInfo) return ((PropertyInfo) member).PropertyType;
                throw new NotSupportedException(member.GetType().Name);
            }
        }
        public bool IsDefined(Type attributeType)
        {
            if (attributeType == null) throw new ArgumentNullException(nameof(attributeType));
#if NETSTD13
            foreach(var attrib in member.CustomAttributes)
            {
                if (attrib.AttributeType == attributeType) return true;
            }
            return false;
#else
            return Attribute.IsDefined(member, attributeType);
#endif
        }
        public Attribute GetAttribute(Type attributeType, bool inherit) => PortableTypeInfo
            .GetCustomAttributes(member, inherit)
            .FirstOrDefault(a => PortableTypeInfo.IsInstanceOf(a, attributeType));
        public bool CanWrite
        {
            get
            {
                var property = member as PropertyInfo;
                if (property == null)
                {
                    throw new NotSupportedException(member.GetType().Name);
                }
                return property.CanWrite;
            }
        }
        public bool CanRead
        {
            get
            {
                var property = member as PropertyInfo;
                if (property == null)
                {
                    throw new NotSupportedException(member.GetType().Name);
                }
                return property.CanRead;
            }
        }
    }
}
#endif
//*** SourceCombiner -> original file ObjectAccessor.cs ***
#if !(NETSTD10 || NETSTD11)
#if !NET35
#endif
namespace PommaLabs.Thrower.Reflection.FastMember
{
    public abstract class ObjectAccessor : IDictionary<string, object>
    {
        public abstract object this[string name] { get; set; }
        public abstract object Target { get; }
        public override bool Equals(object obj) => Target.Equals(obj);
        public override int GetHashCode() => Target.GetHashCode();
        public override string ToString() => Target.ToString();
        public static ObjectAccessor Create(object target) => Create(target, false);
        public static ObjectAccessor Create(object target, bool allowNonPublicAccessors)
        {
            if (target == null) throw new ArgumentNullException(nameof(target));
#if !NET35
            var dlr = target as IDynamicMetaObjectProvider;
#endif
            return new TypeAccessorWrapper(target, TypeAccessor.Create(target.GetType(), allowNonPublicAccessors));
        }
        #region IDictionary<string, object> members
        public abstract ICollection<string> Keys { get; }
        public abstract ICollection<object> Values { get; }
        public abstract int Count { get; }
        public bool IsReadOnly => true;
        public abstract bool ContainsKey(string key);
        public void Add(string key, object value)
        {
            throw new NotSupportedException();
        }
        public bool Remove(string key)
        {
            throw new NotSupportedException();
        }
        public abstract bool TryGetValue(string key, out object value);
        public void Add(KeyValuePair<string, object> item)
        {
            throw new NotSupportedException();
        }
        public void Clear()
        {
            throw new NotSupportedException();
        }
        public abstract bool Contains(KeyValuePair<string, object> item);
        public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex)
        {
            foreach (var kv in this)
            {
                array[arrayIndex++] = kv;
            }
        }
        public bool Remove(KeyValuePair<string, object> item)
        {
            throw new NotSupportedException();
        }
        public abstract IEnumerator<KeyValuePair<string, object>> GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion IDictionary<string, object> members
        private sealed class TypeAccessorWrapper : ObjectAccessor
        {
            private readonly TypeAccessor _accessor;
            private readonly MemberSet _members;
            public TypeAccessorWrapper(object target, TypeAccessor accessor)
            {
                Target = target;
                _accessor = accessor;
                _members = accessor.GetMembers();
            }
            public override object this[string name]
            {
                get { return _accessor[Target, name]; }
                set { _accessor[Target, name] = value; }
            }
            public override object Target { get; }
            #region IDictionary<string, object> members
            public override ICollection<string> Keys => _members.Select(x => x.Name).ToArray();
            public override ICollection<object> Values => _members.Select(x => _accessor[Target, x.Name]).ToArray();
            public override int Count => _members.Count;
            public override bool ContainsKey(string key) => _members.Any(x => x.Name == key);
            public override bool TryGetValue(string key, out object value)
            {
                if (ContainsKey(key))
                {
                    value = _accessor[Target, key];
                    return true;
                }
                value = null;
                return false;
            }
            public override bool Contains(KeyValuePair<string, object> item) => _members.Any(x => x.Name == item.Key && _accessor[Target, item.Key] == item.Value);
            public override IEnumerator<KeyValuePair<string, object>> GetEnumerator()
            {
                foreach (var m in _members)
                {
                    yield return new KeyValuePair<string, object>(m.Name, _accessor[Target, m.Name]);
                }
            }
            #endregion IDictionary<string, object> members
        }
#if !NET35
        private sealed class DynamicWrapper : ObjectAccessor
        {
            public DynamicWrapper(IDynamicMetaObjectProvider target)
            {
                Target = target;
            }
            public override object this[string name]
            {
                get { return CallSiteCache.GetValue(name, Target); }
                set { CallSiteCache.SetValue(name, Target, value); }
            }
            public override object Target { get; }
        #region IDictionary<string, object> members
            public override ICollection<string> Keys
            {
                get { throw new NotSupportedException(); }
            }
            public override ICollection<object> Values
            {
                get { throw new NotSupportedException(); }
            }
            public override int Count
            {
                get { throw new NotSupportedException(); }
            }
            public override bool ContainsKey(string key)
            {
                throw new NotSupportedException();
            }
            public override bool TryGetValue(string key, out object value)
            {
                throw new NotSupportedException();
            }
            public override bool Contains(KeyValuePair<string, object> item)
            {
                throw new NotSupportedException();
            }
            public override IEnumerator<KeyValuePair<string, object>> GetEnumerator()
            {
                throw new NotSupportedException();
            }
        #endregion IDictionary<string, object> members
        }
#endif
    }
}
#endif
//*** SourceCombiner -> original file ObjectReader.cs ***
#if !(NETSTD10 || NETSTD11)
namespace PommaLabs.Thrower.Reflection.FastMember
{
    public class ObjectReader : DbDataReader
    {
        private readonly TypeAccessor _accessor;
        private readonly string[] _memberNames;
        private readonly Type[] _effectiveTypes;
        private readonly BitArray _allowNull;
        private IEnumerator _source;
        private object _current;
        private bool _active = true;
        public static ObjectReader Create<T>(IEnumerable<T> source, params string[] members) => new ObjectReader(typeof(T), source, members);
        public ObjectReader(Type type, IEnumerable source, params string[] members)
        {
            if (source == null) throw new ArgumentOutOfRangeException(nameof(source));
            var allMembers = members == null || members.Length == 0;
            this._accessor = TypeAccessor.Create(type);
            if (_accessor.GetMembersSupported)
            {
                var typeMembers = this._accessor.GetMembers();
                if (allMembers)
                {
                    members = new string[typeMembers.Count];
                    for (int i = 0; i < members.Length; i++)
                    {
                        members[i] = typeMembers[i].Name;
                    }
                }
                this._allowNull = new BitArray(members.Length);
                this._effectiveTypes = new Type[members.Length];
                for (int i = 0; i < members.Length; i++)
                {
                    Type memberType = null;
                    var allowNull = true;
                    var hunt = members[i];
                    foreach (var member in typeMembers)
                    {
                        if (member.Name == hunt)
                        {
                            if (memberType == null)
                            {
                                var tmp = member.Type;
                                memberType = Nullable.GetUnderlyingType(tmp) ?? tmp;
                                allowNull = !(PortableTypeInfo.IsValueType(memberType) && memberType == tmp);
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    this._allowNull[i] = allowNull;
                    this._effectiveTypes[i] = memberType ?? typeof(object);
                }
            }
            else if (allMembers)
            {
                throw new InvalidOperationException("Member information is not available for this type; the required members must be specified explicitly");
            }
            this._current = null;
            this._memberNames = (string[]) members.Clone();
            this._source = source.GetEnumerator();
        }
        public override int Depth => 0;
#if !NETSTD13
        public override DataTable GetSchemaTable()
        {
            var table = new DataTable
            {
                Columns =
                {
                    {"ColumnOrdinal", typeof(int)},
                    {"ColumnName", typeof(string)},
                    {"DataType", typeof(Type)},
                    {"ColumnSize", typeof(int)},
                    {"AllowDBNull", typeof(bool)}
                }
            };
            var rowData = new object[5];
            for (int i = 0; i < _memberNames.Length; i++)
            {
                rowData[0] = i;
                rowData[1] = _memberNames[i];
                rowData[2] = _effectiveTypes == null ? typeof(object) : _effectiveTypes[i];
                rowData[3] = -1;
                rowData[4] = _allowNull == null || _allowNull[i];
                table.Rows.Add(rowData);
            }
            return table;
        }
        public override void Close()
        {
            Shutdown();
        }
#endif
        public override bool HasRows => _active;
        public override bool NextResult()
        {
            _active = false;
            return false;
        }
        public override bool Read()
        {
            if (_active)
            {
                var tmp = _source;
                if (tmp != null && tmp.MoveNext())
                {
                    _current = tmp.Current;
                    return true;
                }
                else
                {
                    _active = false;
                }
            }
            _current = null;
            return false;
        }
        public override int RecordsAffected => 0;
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (disposing) Shutdown();
        }
        private void Shutdown()
        {
            _active = false;
            _current = null;
            var tmp = _source as IDisposable;
            _source = null;
            if (tmp != null) tmp.Dispose();
        }
        public override int FieldCount => _memberNames.Length;
        public override bool IsClosed => _source == null;
        public override bool GetBoolean(int ordinal) => (bool) this[ordinal];
        public override byte GetByte(int ordinal) => (byte) this[ordinal];
        public override long GetBytes(int ordinal, long dataOffset, byte[] buffer, int bufferOffset, int length)
        {
            var s = (byte[]) this[ordinal];
            var available = s.Length - (int) dataOffset;
            if (available <= 0) return 0;
            var count = Min(length, available);
            Buffer.BlockCopy(s, (int) dataOffset, buffer, bufferOffset, count);
            return count;
        }
        public override char GetChar(int ordinal) => (char) this[ordinal];
        public override long GetChars(int ordinal, long dataOffset, char[] buffer, int bufferOffset, int length)
        {
            var s = (string) this[ordinal];
            var available = s.Length - (int) dataOffset;
            if (available <= 0) return 0;
            var count = Min(length, available);
            s.CopyTo((int) dataOffset, buffer, bufferOffset, count);
            return count;
        }
        protected override DbDataReader GetDbDataReader(int ordinal)
        {
            throw new NotSupportedException();
        }
        public override string GetDataTypeName(int ordinal) => (_effectiveTypes == null ? typeof(object) : _effectiveTypes[ordinal]).Name;
        public override DateTime GetDateTime(int ordinal) => (DateTime) this[ordinal];
        public override decimal GetDecimal(int ordinal) => (decimal) this[ordinal];
        public override double GetDouble(int ordinal) => (double) this[ordinal];
        public override Type GetFieldType(int ordinal) => _effectiveTypes == null ? typeof(object) : _effectiveTypes[ordinal];
        public override float GetFloat(int ordinal) => (float) this[ordinal];
        public override Guid GetGuid(int ordinal) => (Guid) this[ordinal];
        public override short GetInt16(int ordinal) => (short) this[ordinal];
        public override int GetInt32(int ordinal) => (int) this[ordinal];
        public override long GetInt64(int ordinal) => (long) this[ordinal];
        public override string GetName(int ordinal) => _memberNames[ordinal];
        public override int GetOrdinal(string name) => Array.IndexOf(_memberNames, name);
        public override string GetString(int ordinal) => (string) this[ordinal];
        public override object GetValue(int ordinal) => this[ordinal];
        public override IEnumerator GetEnumerator() => new DbEnumerator(this, false);
        public override int GetValues(object[] values)
        {
            var members = this._memberNames;
            var current = this._current;
            var accessor = this._accessor;
            var count = Min(values.Length, members.Length);
            for (int i = 0; i < count; i++) values[i] = accessor[current, members[i]] ?? DBNull.Value;
            return count;
        }
        public override bool IsDBNull(int ordinal) => this[ordinal] is DBNull;
        public override object this[string name] => _accessor[_current, name] ?? DBNull.Value;
        public override object this[int ordinal] => _accessor[_current, _memberNames[ordinal]] ?? DBNull.Value;
        private static int Min(int x, int y) => x < y ? x : y;
    }
}
#endif
//*** SourceCombiner -> original file TypeAccessor.cs ***
#if !(NETSTD10 || NETSTD11)
#if !NET35
#endif
namespace PommaLabs.Thrower.Reflection.FastMember
{
#if NET20
    public delegate TResult Func<TResult>();
    public delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);
    public delegate void Action<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3);
#endif
    [SecuritySafeCritical]
    public abstract class TypeAccessor
    {
        private static readonly Hashtable publicAccessorsOnly = new Hashtable(), nonPublicAccessors = new Hashtable();
        public virtual bool CreateNewSupported => false;
        public virtual object CreateNew() { throw new NotSupportedException(); }
        public virtual bool GetMembersSupported => false;
        public virtual MemberSet GetMembers() { throw new NotSupportedException(); }
        public static TypeAccessor Create(Type type) => Create(type, false);
        public static TypeAccessor Create<T>() => Create(typeof(T), false);
        public static TypeAccessor Create(Type type, bool allowNonPublicAccessors)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
            var lookup = allowNonPublicAccessors ? nonPublicAccessors : publicAccessorsOnly;
            var obj = (TypeAccessor) lookup[type];
            if (obj != null) return obj;
            lock (lookup)
            {
                obj = (TypeAccessor) lookup[type];
                if (obj != null) return obj;
                obj = CreateNew(type, allowNonPublicAccessors);
                lookup[type] = obj;
                return obj;
            }
        }
        public static TypeAccessor Create<T>(bool allowNonPublicAccessors) => Create(typeof(T), allowNonPublicAccessors);
#if !NET35
        private sealed class DynamicAccessor : TypeAccessor
        {
            public static readonly DynamicAccessor Singleton = new DynamicAccessor();
            private DynamicAccessor()
            {
            }
            public override object this[object target, string name]
            {
                get { return CallSiteCache.GetValue(name, target); }
                set { CallSiteCache.SetValue(name, target, value); }
            }
        }
#endif
        private static AssemblyBuilder assembly;
        private static ModuleBuilder module;
        private static int counter;
        private static int GetNextCounterValue()
        {
            return Interlocked.Increment(ref counter);
        }
        private static readonly MethodInfo tryGetValue = typeof(Dictionary<string, int>).GetMethod("TryGetValue");
        private static void WriteMapImpl(ILGenerator il, Type type, List<MemberInfo> members, FieldBuilder mapField, bool allowNonPublicAccessors, bool isGet)
        {
            OpCode obj, index, value;
            var fail = il.DefineLabel();
            if (mapField == null)
            {
                index = OpCodes.Ldarg_0;
                obj = OpCodes.Ldarg_1;
                value = OpCodes.Ldarg_2;
            }
            else
            {
                il.DeclareLocal(typeof(int));
                index = OpCodes.Ldloc_0;
                obj = OpCodes.Ldarg_1;
                value = OpCodes.Ldarg_3;
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldfld, mapField);
                il.Emit(OpCodes.Ldarg_2);
                il.Emit(OpCodes.Ldloca_S, (byte) 0);
                il.EmitCall(OpCodes.Callvirt, tryGetValue, null);
                il.Emit(OpCodes.Brfalse, fail);
            }
            var labels = new Label[members.Count];
            for (int i = 0; i < labels.Length; i++)
            {
                labels[i] = il.DefineLabel();
            }
            il.Emit(index);
            il.Emit(OpCodes.Switch, labels);
            il.MarkLabel(fail);
            il.Emit(OpCodes.Ldstr, "name");
            il.Emit(OpCodes.Newobj, typeof(ArgumentOutOfRangeException).GetConstructor(new Type[] { typeof(string) }));
            il.Emit(OpCodes.Throw);
            for (int i = 0; i < labels.Length; i++)
            {
                il.MarkLabel(labels[i]);
                var member = members[i];
                var isFail = true;
                FieldInfo field;
                PropertyInfo prop;
                if ((field = member as FieldInfo) != null)
                {
                    il.Emit(obj);
                    Cast(il, type, true);
                    if (isGet)
                    {
                        il.Emit(OpCodes.Ldfld, field);
                        if (PortableTypeInfo.IsValueType(field.FieldType)) il.Emit(OpCodes.Box, field.FieldType);
                    }
                    else
                    {
                        il.Emit(value);
                        Cast(il, field.FieldType, false);
                        il.Emit(OpCodes.Stfld, field);
                    }
                    il.Emit(OpCodes.Ret);
                    isFail = false;
                }
                else if ((prop = member as PropertyInfo) != null)
                {
                    MethodInfo accessor;
                    if (prop.CanRead && (accessor = isGet ? prop.GetGetMethod(allowNonPublicAccessors) : prop.GetSetMethod(allowNonPublicAccessors)) != null)
                    {
                        il.Emit(obj);
                        Cast(il, type, true);
                        if (isGet)
                        {
                            il.EmitCall(PortableTypeInfo.IsValueType(type) ? OpCodes.Call : OpCodes.Callvirt, accessor, null);
                            if (PortableTypeInfo.IsValueType(prop.PropertyType)) il.Emit(OpCodes.Box, prop.PropertyType);
                        }
                        else
                        {
                            il.Emit(value);
                            Cast(il, prop.PropertyType, false);
                            il.EmitCall(PortableTypeInfo.IsValueType(type) ? OpCodes.Call : OpCodes.Callvirt, accessor, null);
                        }
                        il.Emit(OpCodes.Ret);
                        isFail = false;
                    }
                }
                if (isFail) il.Emit(OpCodes.Br, fail);
            }
        }
        private static readonly MethodInfo strinqEquals = typeof(string).GetMethod("op_Equality", new Type[] { typeof(string), typeof(string) });
        protected abstract class RuntimeTypeAccessor : TypeAccessor
        {
            protected abstract Type Type { get; }
            public override bool GetMembersSupported => true;
            private MemberSet members;
            public override MemberSet GetMembers() => members ?? (members = new MemberSet(Type));
        }
        private sealed class DelegateAccessor : RuntimeTypeAccessor
        {
            private readonly Dictionary<string, int> map;
            private readonly Func<int, object, object> getter;
            private readonly Action<int, object, object> setter;
            private readonly Func<object> ctor;
            private readonly Type type;
            protected override Type Type => type;
            public DelegateAccessor(Dictionary<string, int> map, Func<int, object, object> getter, Action<int, object, object> setter, Func<object> ctor, Type type)
            {
                this.map = map;
                this.getter = getter;
                this.setter = setter;
                this.ctor = ctor;
                this.type = type;
            }
            public override bool CreateNewSupported => ctor != null;
            public override object CreateNew() => ctor != null ? ctor() : base.CreateNew();
            public override object this[object target, string name]
            {
                get
                {
                    int index;
                    if (map.TryGetValue(name, out index)) return getter(index, target);
                    else throw new ArgumentOutOfRangeException(nameof(name));
                }
                set
                {
                    int index;
                    if (map.TryGetValue(name, out index)) setter(index, target, value);
                    else throw new ArgumentOutOfRangeException(nameof(name));
                }
            }
        }
        private static bool IsFullyPublic(Type type, PropertyInfo[] props, bool allowNonPublicAccessors)
        {
            while (PortableTypeInfo.IsNestedPublic(type)) type = type.DeclaringType;
            if (!PortableTypeInfo.IsPublic(type)) return false;
            if (allowNonPublicAccessors)
            {
                for (int i = 0; i < props.Length; i++)
                {
                }
            }
            return true;
        }
        [SecuritySafeCritical]
        private static TypeAccessor CreateNew(Type type, bool allowNonPublicAccessors)
        {
#if !NET35
            if (typeof(IDynamicMetaObjectProvider).IsAssignableFrom(type))
            {
                return DynamicAccessor.Singleton;
            }
#endif
            var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
            var fields = type.GetFields(BindingFlags.Public | BindingFlags.Instance);
            var map = new Dictionary<string, int>();
            var members = new List<MemberInfo>(props.Length + fields.Length);
            var i = 0;
            foreach (var prop in props)
            {
                if (!map.ContainsKey(prop.Name) && prop.GetIndexParameters().Length == 0)
                {
                    map.Add(prop.Name, i++);
                    members.Add(prop);
                }
            }
            foreach (var field in fields) if (!map.ContainsKey(field.Name)) { map.Add(field.Name, i++); members.Add(field); }
            ConstructorInfo ctor = null;
            if (PortableTypeInfo.IsClass(type) && !PortableTypeInfo.IsAbstract(type))
            {
                ctor = type.GetConstructor(PortableTypeInfo.EmptyTypes);
            }
            ILGenerator il;
            if (!IsFullyPublic(type, props, allowNonPublicAccessors))
            {
                var dynGetter = new DynamicMethod(type.FullName + "_get", typeof(object), new Type[] { typeof(int), typeof(object) }, type, true);
                var dynSetter = new DynamicMethod(type.FullName + "_set", null, new Type[] { typeof(int), typeof(object), typeof(object) }, type, true);
                WriteMapImpl(dynGetter.GetILGenerator(), type, members, null, allowNonPublicAccessors, true);
                WriteMapImpl(dynSetter.GetILGenerator(), type, members, null, allowNonPublicAccessors, false);
                DynamicMethod dynCtor = null;
                if (ctor != null)
                {
                    dynCtor = new DynamicMethod(type.FullName + "_ctor", typeof(object), PortableTypeInfo.EmptyTypes, type, true);
                    il = dynCtor.GetILGenerator();
                    il.Emit(OpCodes.Newobj, ctor);
                    il.Emit(OpCodes.Ret);
                }
                return new DelegateAccessor(
                    map,
                    (Func<int, object, object>) dynGetter.CreateDelegate(typeof(Func<int, object, object>)),
                    (Action<int, object, object>) dynSetter.CreateDelegate(typeof(Action<int, object, object>)),
                    dynCtor == null ? null : (Func<object>) dynCtor.CreateDelegate(typeof(Func<object>)), type);
            }
            if (assembly == null)
            {
                var name = new AssemblyName("FastMember_dynamic");
#if NETSTD13
                assembly = AssemblyBuilder.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
#else
                assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
#endif
                module = assembly.DefineDynamicModule(name.Name);
            }
#if NETSTD13
            var attribs = typeof(TypeAccessor).GetTypeInfo().Attributes;
#else
            var attribs = typeof(TypeAccessor).Attributes;
#endif
            var tb = module.DefineType("FastMember_dynamic." + type.Name + "_" + GetNextCounterValue(),
                (attribs | TypeAttributes.Sealed | TypeAttributes.Public) & ~(TypeAttributes.Abstract | TypeAttributes.NotPublic), typeof(RuntimeTypeAccessor));
            il = tb.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new[] {
                typeof(Dictionary<string,int>)
            }).GetILGenerator();
            il.Emit(OpCodes.Ldarg_0);
            il.Emit(OpCodes.Ldarg_1);
            var mapField = tb.DefineField("_map", typeof(Dictionary<string, int>), FieldAttributes.InitOnly | FieldAttributes.Private);
            il.Emit(OpCodes.Stfld, mapField);
            il.Emit(OpCodes.Ret);
            var indexer = typeof(TypeAccessor).GetProperty("Item");
            var baseGetter = indexer.GetGetMethod();
            var baseSetter = indexer.GetSetMethod();
            var body = tb.DefineMethod(baseGetter.Name, baseGetter.Attributes & ~MethodAttributes.Abstract, typeof(object), new Type[] { typeof(object), typeof(string) });
            il = body.GetILGenerator();
            WriteMapImpl(il, type, members, mapField, allowNonPublicAccessors, true);
            tb.DefineMethodOverride(body, baseGetter);
            body = tb.DefineMethod(baseSetter.Name, baseSetter.Attributes & ~MethodAttributes.Abstract, null, new Type[] { typeof(object), typeof(string), typeof(object) });
            il = body.GetILGenerator();
            WriteMapImpl(il, type, members, mapField, allowNonPublicAccessors, false);
            tb.DefineMethodOverride(body, baseSetter);
            MethodInfo baseMethod;
            if (ctor != null)
            {
                baseMethod = typeof(TypeAccessor).GetProperty(nameof(CreateNewSupported)).GetGetMethod();
                body = tb.DefineMethod(baseMethod.Name, baseMethod.Attributes, baseMethod.ReturnType, PortableTypeInfo.EmptyTypes);
                il = body.GetILGenerator();
                il.Emit(OpCodes.Ldc_I4_1);
                il.Emit(OpCodes.Ret);
                tb.DefineMethodOverride(body, baseMethod);
                baseMethod = typeof(TypeAccessor).GetMethod(nameof(CreateNew));
                body = tb.DefineMethod(baseMethod.Name, baseMethod.Attributes, baseMethod.ReturnType, PortableTypeInfo.EmptyTypes);
                il = body.GetILGenerator();
                il.Emit(OpCodes.Newobj, ctor);
                il.Emit(OpCodes.Ret);
                tb.DefineMethodOverride(body, baseMethod);
            }
            baseMethod = typeof(RuntimeTypeAccessor).GetProperty("Type", BindingFlags.NonPublic | BindingFlags.Instance).GetGetMethod(true);
            body = tb.DefineMethod(baseMethod.Name, baseMethod.Attributes & ~MethodAttributes.Abstract, baseMethod.ReturnType, PortableTypeInfo.EmptyTypes);
            il = body.GetILGenerator();
            il.Emit(OpCodes.Ldtoken, type);
            il.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle"));
            il.Emit(OpCodes.Ret);
            tb.DefineMethodOverride(body, baseMethod);
#if NETSTD13
            var typeToBeCreated = tb.CreateTypeInfo().AsType();
#else
            var typeToBeCreated = tb.CreateType();
#endif
            var accessor = (TypeAccessor) Activator.CreateInstance(typeToBeCreated, map);
            return accessor;
        }
        private static void Cast(ILGenerator il, Type type, bool valueAsPointer)
        {
            if (type == typeof(object)) { }
            else if (PortableTypeInfo.IsValueType(type))
            {
                if (valueAsPointer)
                {
                    il.Emit(OpCodes.Unbox, type);
                }
                else
                {
                    il.Emit(OpCodes.Unbox_Any, type);
                }
            }
            else
            {
                il.Emit(OpCodes.Castclass, type);
            }
        }
        public abstract object this[object target, string name]
        {
            get;
            set;
        }
    }
}
#endif
//*** SourceCombiner -> original file EmailAddressAttribute.cs ***
#if !NET35
namespace PommaLabs.Thrower.Validation
{
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
    public class EmailAddressAttribute : DataTypeAttribute
    {
        public EmailAddressAttribute() : base(DataType.EmailAddress)
        {
            ErrorMessage = "Field '{0}' is not a valid e-mail address.";
        }
        public EmailAddressValidator.Options Options { get; set; }
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            if (value == null)
            {
                return ValidationResult.Success;
            }
            var str = value as string;
            if (str != null)
            {
                return EmailAddressValidator.Validate(str, Options)
                    ? ValidationResult.Success
                    : new ValidationResult($"Given string '{str}' is not a valid email address", new[] { validationContext.MemberName });
            }
            return new ValidationResult("Given object is not a valid email address", new[] { validationContext.MemberName });
        }
    }
}
#endif
//*** SourceCombiner -> original file EmailAddressValidator.cs ***
namespace PommaLabs.Thrower.Validation
{
    public static class EmailAddressValidator
    {
        private const string AtomCharacters = "!#$%&'*+-/=?^_`{|}~";
        private static bool IsLetterOrDigit(char c)
        {
            return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
        }
        private static bool IsAtom(char c, bool allowInternational)
        {
            return c < 128 ? IsLetterOrDigit(c) || AtomCharacters.IndexOf(c) != -1 : allowInternational;
        }
        private static bool IsDomain(char c, bool allowInternational)
        {
            return c < 128 ? IsLetterOrDigit(c) || c == '-' : allowInternational;
        }
        private static bool SkipAtom(string text, ref int index, bool allowInternational)
        {
            var startIndex = index;
            while (index < text.Length && IsAtom(text[index], allowInternational))
                index++;
            return index > startIndex;
        }
        private static bool SkipSubDomain(string text, ref int index, bool allowInternational)
        {
            var startIndex = index;
            if (!IsDomain(text[index], allowInternational) || text[index] == '-')
                return false;
            index++;
            while (index < text.Length && IsDomain(text[index], allowInternational))
                index++;
            return (index - startIndex) < 64 && text[index - 1] != '-';
        }
        private static bool SkipDomain(string text, ref int index, bool allowInternational, bool allowTopLevelDomains)
        {
            if (!SkipSubDomain(text, ref index, allowInternational))
                return false;
            if (index < text.Length && text[index] == '.')
            {
                do
                {
                    index++;
                    if (index == text.Length)
                        return false;
                    if (!SkipSubDomain(text, ref index, allowInternational))
                        return false;
                } while (index < text.Length && text[index] == '.');
            }
            else if (!allowTopLevelDomains)
            {
                return false;
            }
            return true;
        }
        private static bool SkipQuoted(string text, ref int index, bool allowInternational)
        {
            var escaped = false;
            index++;
            while (index < text.Length)
            {
                if (text[index] >= 128 && !allowInternational)
                    return false;
                if (text[index] == '\\')
                {
                    escaped = !escaped;
                }
                else if (!escaped)
                {
                    if (text[index] == '"')
                        break;
                }
                else
                {
                    escaped = false;
                }
                index++;
            }
            if (index >= text.Length || text[index] != '"')
                return false;
            index++;
            return true;
        }
        private static bool SkipWord(string text, ref int index, bool allowInternational)
        {
            if (text[index] == '"')
                return SkipQuoted(text, ref index, allowInternational);
            return SkipAtom(text, ref index, allowInternational);
        }
        private static bool SkipIPv4Literal(string text, ref int index)
        {
            var groups = 0;
            while (index < text.Length && groups < 4)
            {
                var startIndex = index;
                var value = 0;
                while (index < text.Length && text[index] >= '0' && text[index] <= '9')
                {
                    value = (value * 10) + (text[index] - '0');
                    index++;
                }
                if (index == startIndex || index - startIndex > 3 || value > 255)
                    return false;
                groups++;
                if (groups < 4 && index < text.Length && text[index] == '.')
                    index++;
            }
            return groups == 4;
        }
        private static bool IsHexDigit(char c)
        {
            return (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') || (c >= '0' && c <= '9');
        }
        private static bool SkipIPv6Literal(string text, ref int index)
        {
            var compact = false;
            var colons = 0;
            while (index < text.Length)
            {
                var startIndex = index;
                while (index < text.Length && IsHexDigit(text[index]))
                    index++;
                if (index >= text.Length)
                    break;
                if (index > startIndex && colons > 2 && text[index] == '.')
                {
                    index = startIndex;
                    if (!SkipIPv4Literal(text, ref index))
                        return false;
                    return compact ? colons < 6 : colons == 6;
                }
                var count = index - startIndex;
                if (count > 4)
                    return false;
                if (text[index] != ':')
                    break;
                startIndex = index;
                while (index < text.Length && text[index] == ':')
                    index++;
                count = index - startIndex;
                if (count > 2)
                    return false;
                if (count == 2)
                {
                    if (compact)
                        return false;
                    compact = true;
                    colons += 2;
                }
                else
                {
                    colons++;
                }
            }
            if (colons < 2)
                return false;
            return compact ? colons < 7 : colons == 7;
        }
        public static bool Validate(string emailAddress, Options options = Options.None)
        {
            var allowInternational = ((options & Options.AllowInternational) == Options.AllowInternational);
            var allowTopLevelDomains = ((options & Options.AllowTopLevelDomains) == Options.AllowTopLevelDomains);
            var index = 0;
            if (emailAddress == null)
                throw new ArgumentNullException(nameof(emailAddress));
            if (emailAddress.Length == 0 || emailAddress.Length >= 255)
                return false;
            if (!SkipWord(emailAddress, ref index, allowInternational) || index >= emailAddress.Length)
                return false;
            while (emailAddress[index] == '.')
            {
                index++;
                if (index >= emailAddress.Length)
                    return false;
                if (!SkipWord(emailAddress, ref index, allowInternational))
                    return false;
                if (index >= emailAddress.Length)
                    return false;
            }
            if (index + 1 >= emailAddress.Length || index > 64 || emailAddress[index++] != '@')
                return false;
            if (emailAddress[index] != '[')
            {
                if (!SkipDomain(emailAddress, ref index, allowInternational, allowTopLevelDomains))
                    return false;
                return index == emailAddress.Length;
            }
            index++;
            if (index + 8 >= emailAddress.Length)
                return false;
            var ipv6 = emailAddress.Substring(index, 5);
            if (ipv6.ToLowerInvariant() == "ipv6:")
            {
                index += "IPv6:".Length;
                if (!SkipIPv6Literal(emailAddress, ref index))
                    return false;
            }
            else
            {
                if (!SkipIPv4Literal(emailAddress, ref index))
                    return false;
            }
            if (index >= emailAddress.Length || emailAddress[index++] != ']')
                return false;
            return index == emailAddress.Length;
        }
        [Flags]
        public enum Options
        {
            None = 0,
            AllowInternational = 1,
            AllowTopLevelDomains = 2
        }
    }
}
//*** SourceCombiner -> original file EnumerationAttribute.cs ***
#if !NET35
namespace PommaLabs.Thrower.Validation
{
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
    public class EnumerationAttribute : DataTypeAttribute
    {
        public EnumerationAttribute() : base(DataType.PhoneNumber)
        {
            ErrorMessage = "Field '{0}' has not a valid enumeration value.";
        }
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            if (value != null)
            {
                return EnumerationValidator.Validate(value.GetType(), value)
                    ? ValidationResult.Success
                    : new ValidationResult($"Given value '{value}' is not a valid enumeration value", new[] { validationContext.MemberName });
            }
            return new ValidationResult("Given object is not a valid enumeration value", new[] { validationContext.MemberName });
        }
    }
}
#endif
//*** SourceCombiner -> original file EnumerationValidator.cs ***
namespace PommaLabs.Thrower.Validation
{
    public static class EnumerationValidator
    {
        public static bool Validate<TEnum>(TEnum? value)
            where TEnum : struct
        {
            if (!PortableTypeInfo.IsEnum(CachedEnumValidator<TEnum>.EnumType))
            {
                return false;
            }
            return value.HasValue ? Validate(value.Value) : true;
        }
        public static bool Validate<TEnum>(TEnum value)
            where TEnum : struct
        {
            if (!PortableTypeInfo.IsEnum(CachedEnumValidator<TEnum>.EnumType))
            {
                return false;
            }
            if (Enum.IsDefined(CachedEnumValidator<TEnum>.EnumType, value))
            {
                return true;
            }
            if (CachedEnumValidator<TEnum>.HasFlagsAttribute)
            {
                var intValue = PortableTypeInfo.CastTo<int>.From(value);
                return (CachedEnumValidator<TEnum>.Mask & intValue) == intValue;
            }
            return false;
        }
        public static bool Validate(Type enumType, object value)
        {
            bool? isReallyAnEnum = null;
            if (PortableTypeInfo.IsGenericType(enumType) && ReferenceEquals(PortableTypeInfo.GetGenericTypeDefinition(enumType), typeof(Nullable<>)))
            {
                var innerEnumType = PortableTypeInfo.GetGenericTypeArguments(enumType)[0];
                isReallyAnEnum = PortableTypeInfo.IsEnum(innerEnumType);
                if (isReallyAnEnum.Value && ReferenceEquals(value, null))
                {
                    return true;
                }
                if (value.GetType() == enumType)
                {
                    if (!PortableTypeInfo.GetPublicPropertyValue<bool>(value, nameof(Nullable<byte>.HasValue)))
                    {
                        return isReallyAnEnum.Value;
                    }
                    value = PortableTypeInfo.GetPublicPropertyValue(value, nameof(Nullable<byte>.Value));
                }
                enumType = innerEnumType;
            }
            if ((isReallyAnEnum.HasValue && !isReallyAnEnum.Value) || !PortableTypeInfo.IsEnum(enumType))
            {
                return false;
            }
            if (Enum.IsDefined(enumType, value))
            {
                return true;
            }
            var hasFlagsAttribute = TypeHasFlagsAttribute(enumType);
            if (hasFlagsAttribute)
            {
                var mask = 0;
                foreach (var enumValue in Enum.GetValues(enumType))
                {
                    mask = mask | (int) enumValue;
                }
                var intValue = (int) value;
                return (mask & intValue) == intValue;
            }
            return false;
        }
        private static bool TypeHasFlagsAttribute(Type enumType) => PortableTypeInfo
             .GetCustomAttributes(enumType, true)
             ?.Any(a => a is FlagsAttribute) ?? false;
        private static class CachedEnumValidator<TEnum>
            where TEnum : struct
        {
            static CachedEnumValidator()
            {
                EnumType = typeof(TEnum);
                HasFlagsAttribute = TypeHasFlagsAttribute(EnumType);
                if (HasFlagsAttribute)
                {
                    var mask = 0;
                    foreach (var enumValue in Enum.GetValues(EnumType))
                    {
                        mask = mask | (int) enumValue;
                    }
                    Mask = mask;
                }
            }
            public static Type EnumType { get; }
            public static bool HasFlagsAttribute { get; }
            public static int Mask { get; }
        }
    }
}
//*** SourceCombiner -> original file ObjectValidator.cs ***
namespace PommaLabs.Thrower.Validation
{
    public static class ObjectValidator
    {
        public const string RootPlaceholder = "$";
        private static readonly ValidateAttribute DefaultValidation = new ValidateAttribute();
        private static readonly HashSet<Type> AlwaysValidTypes = new HashSet<Type>
        {
            typeof(bool),
            typeof(char),
            typeof(byte),
            typeof(short),
            typeof(ushort),
            typeof(int),
            typeof(uint),
            typeof(long),
            typeof(ulong),
            typeof(float),
            typeof(double),
            typeof(decimal),
            typeof(string)
        };
        public static string FormatValidationErrors(IEnumerable<ValidationError> validationErrors, string startMessage = null)
        {
            var builder = new StringBuilder();
            if (!string.IsNullOrEmpty(startMessage))
            {
                builder.Append(startMessage);
                builder.Append(" - ");
            }
            builder.AppendLine("Following paths failed the validation checks:");
            foreach (var ve in validationErrors)
            {
                builder.AppendLine($" >> {ve.Path}: {ve.Reason}");
            }
            return builder.ToString();
        }
        public static bool Validate(object obj, out IList<ValidationError> validationErrors)
        {
            validationErrors = new List<ValidationError>();
#if !NET35
            var netValidationErrors = new List<System.ComponentModel.DataAnnotations.ValidationResult>();
#if NET40
            var netValidationContext = new System.ComponentModel.DataAnnotations.ValidationContext(obj, null, null);
#else
            var netValidationContext = new System.ComponentModel.DataAnnotations.ValidationContext(obj);
#endif
            if (!System.ComponentModel.DataAnnotations.Validator.TryValidateObject(obj, netValidationContext, netValidationErrors, true))
            {
                foreach (var netValidationError in netValidationErrors)
                    foreach (var memberName in netValidationError.MemberNames)
                    {
                        validationErrors.Add(new ValidationError
                        {
                            Path = $"{RootPlaceholder}.{memberName}",
                            Reason = netValidationError.ErrorMessage
                        });
                    }
            }
#endif
            return ValidateInternal(obj, RootPlaceholder, DefaultValidation, validationErrors);
        }
        private static bool ValidateInternal(object obj, string path, ValidateAttribute validation, IList<ValidationError> validationErrors)
        {
            if (ReferenceEquals(obj, null))
            {
                if (validation.Required)
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = "Property is required, found null" });
                    return false;
                }
                return true;
            }
            var objType = obj.GetType();
            if (AlwaysValidTypes.Contains(objType) || PortableTypeInfo.IsEnum(objType))
            {
                return true;
            }
            var isValueType = PortableTypeInfo.IsValueType(objType);
            if (validation.Required && isValueType && PortableTypeInfo.IsGenericType(objType) && objType.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                var nullableProps = PortableTypeInfo.GetPublicProperties(objType);
                var nullableHasValueProp = nullableProps.First(p => p.Name == nameof(Nullable<bool>.HasValue));
                if ((bool) PortableTypeInfo.GetPublicPropertyValue(obj, nullableHasValueProp))
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = "Property is required, found null" });
                    return false;
                }
                var nullableValueProp = nullableProps.First(p => p.Name == nameof(Nullable<bool>.Value));
                var nullableValue = PortableTypeInfo.GetPublicPropertyValue(obj, nullableValueProp);
                return ValidateInternal(nullableValue, path, validation, validationErrors);
            }
            var collection = obj as ICollection;
            if (collection != null)
            {
                var c = collection.Count;
                if (c < validation.CollectionItemsMinCount)
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = $"Minimum item count is {validation.CollectionItemsMinCount}, found {c}" });
                }
                if (c > validation.CollectionItemsMaxCount)
                {
                    validationErrors.Add(new ValidationError { Path = path, Reason = $"Maximum item count is {validation.CollectionItemsMaxCount}, found {c}" });
                }
            }
            var enumerable = obj as IEnumerable;
            if (enumerable != null && validation.Enumerable)
            {
                var itemValidation = new ValidateAttribute { Required = validation.EnumerableItemsRequired };
                var index = 0;
                foreach (var item in enumerable)
                {
                    var indexedNewPath = $"{path}[{index++}]";
                    ValidateInternal(item, indexedNewPath, itemValidation, validationErrors);
                }
            }
            if (PortableTypeInfo.IsClass(objType) || isValueType)
            {
                var props = PortableTypeInfo.GetPublicProperties(objType);
                var reqProps = from p in props
                               from a in PortableTypeInfo.GetCustomAttributes(p, false)
                               let v = a as ValidateAttribute
                               where v != null
                               select new { PropertyInfo = p, Validation = v };
#if !(NETSTD10 || NETSTD11)
                var typeAccessor = Reflection.FastMember.TypeAccessor.Create(objType);
#endif
                foreach (var rp in reqProps)
                {
                    var propertyInfo = rp.PropertyInfo;
#if (NETSTD10 || NETSTD11)
                    var propertyValue = PortableTypeInfo.GetPublicPropertyValue(obj, propertyInfo);
#else
                    var propertyValue = PortableTypeInfo.GetPublicPropertyValue(typeAccessor, obj, propertyInfo);
#endif
                    var newPath = $"{path}.{propertyInfo.Name}";
                    ValidateInternal(propertyValue, newPath, rp.Validation, validationErrors);
                }
                return validationErrors.Count == 0;
            }
            return true;
        }
    }
}
//*** SourceCombiner -> original file PhoneNumberAttribute.cs ***
#if !NET35
namespace PommaLabs.Thrower.Validation
{
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
    public class PhoneNumberAttribute : DataTypeAttribute
    {
        public PhoneNumberAttribute() : base(DataType.PhoneNumber)
        {
            ErrorMessage = "Field '{0}' is not a valid phone number.";
        }
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            if (value == null)
            {
                return ValidationResult.Success;
            }
            var str = value as string;
            if (str != null)
            {
                return PhoneNumberValidator.Validate(str)
                    ? ValidationResult.Success
                    : new ValidationResult($"Given string '{str}' is not a valid phone number", new[] { validationContext.MemberName });
            }
            return new ValidationResult("Given object is not a valid phone number", new[] { validationContext.MemberName });
        }
    }
}
#endif
//*** SourceCombiner -> original file PhoneNumberValidator.cs ***
namespace PommaLabs.Thrower.Validation
{
    public static class PhoneNumberValidator
    {
        private static readonly Regex PhoneNumberRegex = CreatePhoneNumberRegex();
        public static bool Validate(string phoneNumber)
        {
            Raise.ArgumentException.IfIsNullOrWhiteSpace(phoneNumber, nameof(phoneNumber));
            return PhoneNumberRegex.IsMatch(phoneNumber);
        }
        private static Regex CreatePhoneNumberRegex()
        {
            const string pattern = @"^(\+\s?)?((?<!\+.*)\(\+?\d+([\s\-\/\.]?\d+)?\)|\d+)([\s\-\/\.]?(\(\d+([\s\-\/\.]?\d+)?\)|\d+))*(\s?(x|ext\.?)\s?\d+)?$";
#if (NETSTD10 || NETSTD11)
            const RegexOptions options = RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture;
#else
            const RegexOptions options = RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture;
#endif
            return new Regex(pattern, options);
        }
    }
}
//*** SourceCombiner -> original file ValidateAttribute.cs ***
namespace PommaLabs.Thrower.Validation
{
    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
    public sealed class ValidateAttribute : Attribute
    {
        public bool Required { get; set; } = false;
        public bool Enumerable { get; set; } = true;
        public bool EnumerableItemsRequired { get; set; } = false;
        public long CollectionItemsMinCount { get; set; } = 0L;
        public long CollectionItemsMaxCount { get; set; } = long.MaxValue;
    }
}
//*** SourceCombiner -> original file ValidationError.cs ***
namespace PommaLabs.Thrower.Validation
{
    [Serializable]
    public struct ValidationError
    {
        public string Path { get; set; }
        public string Reason { get; set; }
    }
}
